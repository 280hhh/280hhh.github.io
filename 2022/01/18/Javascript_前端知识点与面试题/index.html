<!DOCTYPE html>


<html lang="zh-Hans">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    Javascript_前端知识点与面试题 |  
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Javascript_前端知识点与面试题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Javascript_前端知识点与面试题
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/01/18/Javascript_%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time datetime="2022-01-18T07:47:44.709Z" itemprop="datePublished">2022-01-18</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">6.6k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">25 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><hr>
<p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Hi!$&#123;name&#125;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test = sayHi(<span class="string">&#x27;xiaoming&#x27;</span>)</span><br><span class="line">test()<span class="comment">//Hi! xiaoming</span></span><br></pre></td></tr></table></figure>

<p>虽然sayHi函数已执行完毕，但是其活动对象也不会被销毁，因为test函数仍然引用着sayHi函数中的变量name，这就是闭包。</p>
<h4 id="利用闭包实现私有属性"><a href="#利用闭包实现私有属性" class="headerlink" title="利用闭包实现私有属性"></a>利用闭包实现私有属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="function"><span class="title">getVal</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> value &#125;,</span><br><span class="line">        <span class="function"><span class="title">setVal</span>(<span class="params">val</span>)</span>&#123; value = val &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>上面的代码，就实现了一个私有属性<code>value</code>，它只能通过<code>getVal()</code>来获取值，通过<code>setVal(val)</code>来设置值。</p>
<h3 id="使用let、var和const创建变量有什么区别"><a href="#使用let、var和const创建变量有什么区别" class="headerlink" title="使用let、var和const创建变量有什么区别"></a>使用let、var和const创建变量有什么区别</h3><hr>
<p>用var声明的变量的作用域是它当前执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。let和const是块级作用域，意味着它们只能在最近的一组花括号(function、if-else代码块或for循环中)中访问。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//所有变量在函数中都可访问</span></span><br><span class="line">    <span class="keyword">var</span> bar = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> baz = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> qux = <span class="string">&#x27;qux&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(bar);<span class="comment">//bar</span></span><br><span class="line">    <span class="built_in">console</span>.log(baz);<span class="comment">//baz</span></span><br><span class="line">    <span class="built_in">console</span>.log(qux);<span class="comment">//qux</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar);<span class="comment">//ReferenceError: bar is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(baz);<span class="comment">//ReferenceError: baz is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(qux);<span class="comment">//ReferenceError: qux is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">if</span>(<span class="params"><span class="literal">true</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> baz = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> qux = <span class="string">&#x27;qux&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用 var 声明的变量在函数作用域上都可访问</span></span><br><span class="line"><span class="built_in">console</span>.log(bar);<span class="comment">//bar</span></span><br><span class="line"><span class="comment">//let 和 const 定义的变量在它们被定义的语句块之外不可访问</span></span><br><span class="line"><span class="built_in">console</span>.log(baz);<span class="comment">//ReferenceError: baz is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(qux);<span class="comment">//ReferenceError: qux is not defined</span></span><br></pre></td></tr></table></figure>

<p>var会使变量提升，这意味着变量可以在声明之前使用。let和const不会使变量提升，提前使用会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(baz);<span class="comment">//ReferenceError: can&#x27;t access lexical declaration &#x27;baz&#x27; before i</span></span><br><span class="line"><span class="keyword">let</span> baz = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bar);<span class="comment">//ReferenceError: can&#x27;t access lexical declaration &#x27;bar&#x27; before i</span></span><br></pre></td></tr></table></figure>

<p>用var重复声明不会报错，但let和const会。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);<span class="comment">//&quot;bar&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baz = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> baz = <span class="string">&#x27;qux&#x27;</span>;<span class="comment">// Uncaught SyntaxError: Identifier &#x27;baz&#x27; has already been declared</span></span><br></pre></td></tr></table></figure>

<p>let和const的区别在于：let允许多次赋值，而const只允许一次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样不会报错。</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样会报错</span></span><br><span class="line"><span class="keyword">const</span> baz = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line">baz = <span class="string">&#x27;qux&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="JavaScript为什么要进行变量提升，它导致了什么问题？"><a href="#JavaScript为什么要进行变量提升，它导致了什么问题？" class="headerlink" title="JavaScript为什么要进行变量提升，它导致了什么问题？"></a>JavaScript为什么要进行变量提升，它导致了什么问题？</h3><hr>
<p>变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。</p>
<p>造成变量声明提升的<strong>本质原因</strong>是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。</p>
<p>首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。</p>
<ul>
<li><p><strong>在解析阶段</strong>，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p>
<ul>
<li>全局上下文：变量定义，函数声明</li>
<li>函数上下文：变量定义，函数声明，this，arguments</li>
</ul>
</li>
<li><p><strong>在执行阶段</strong>，就是按照代码的顺序依次执行。</p>
</li>
</ul>
<p>那为什么会进行变量提升呢？主要有以下两个原因：</p>
<ul>
<li>提高性能</li>
<li>容错性更好</li>
</ul>
<p><strong>1.提高性能</strong> 在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。</p>
<p>在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。</p>
<p><strong>2.容错性更好</strong></p>
<p>变量提升可以在一定程度上提高JS的容错性，看下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;<span class="keyword">var</span> a;<span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。</p>
<p>虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。</p>
<p><strong>总结：</strong></p>
<ul>
<li>解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间</li>
<li>声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</li>
</ul>
<p>变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(tmp);</span><br><span class="line">	<span class="function"><span class="title">if</span>(<span class="params"><span class="literal">false</span></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; tmp.length; i++) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(tmp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。</p>
<h3 id="cookie、localStorage、sessionStorage的区别"><a href="#cookie、localStorage、sessionStorage的区别" class="headerlink" title="cookie、localStorage、sessionStorage的区别"></a>cookie、localStorage、sessionStorage的区别</h3><hr>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">cookie</th>
<th align="center">localStorage</th>
<th align="center">sessionStorage</th>
</tr>
</thead>
<tbody><tr>
<td align="center">由谁初始化</td>
<td align="center">客户端或服务器，服务器可以使用<code>Set-Cookie</code>请求头</td>
<td align="center">客户端</td>
<td align="center">客户端</td>
</tr>
<tr>
<td align="center">数据的生命周期</td>
<td align="center">一般由服务器生成，可设置失效时间，如果在浏览器生成，默认是关闭浏览器之后生效</td>
<td align="center">永久保存，可清除</td>
<td align="center">仅在当前会话有效，关闭页面后清除</td>
</tr>
<tr>
<td align="center">存放数据大小</td>
<td align="center">4KB</td>
<td align="center">5MB</td>
<td align="center">5MB</td>
</tr>
<tr>
<td align="center">与服务器通信</td>
<td align="center">每次都会携带在Http请求头中，如果使用cookie保存过多数据会带来性能问题</td>
<td align="center">仅在客户端保存</td>
<td align="center">仅在客户端保存</td>
</tr>
<tr>
<td align="center">用途</td>
<td align="center">一般由服务器生成，用于标识用户身份</td>
<td align="center">用于浏览器缓存数据</td>
<td align="center">用于浏览器缓存数据</td>
</tr>
<tr>
<td align="center">访问权限</td>
<td align="center">任意窗口</td>
<td align="center">任意窗口</td>
<td align="center">当前页面窗口</td>
</tr>
</tbody></table>
<h3 id="bind、call、apply的区别"><a href="#bind、call、apply的区别" class="headerlink" title="bind、call、apply的区别"></a>bind、call、apply的区别</h3><hr>
<p>call和apply其实是一样的，区别就在于传参时参数时一个一个传或者是以一个数组的方式来传。</p>
<p>call和apply都是在调用时生效，改变调用者的this指向。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;Hi!&#x27;</span> + <span class="built_in">this</span>.name)&#125;</span><br><span class="line"></span><br><span class="line">sayHi()<span class="comment">//Hi!Jack</span></span><br><span class="line">sayHi.call(obj)<span class="comment">//Hi!Tom</span></span><br></pre></td></tr></table></figure>

<p>bind也是改变this指向，不过不是在调用时生效，而是返回一个新函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newFunc = sayHi.bind(obj)</span><br><span class="line">newFunc() <span class="comment">// Hi!Tom</span></span><br></pre></td></tr></table></figure>

<h4 id="实现bind-call-apply函数"><a href="#实现bind-call-apply函数" class="headerlink" title="实现bind call apply函数"></a>实现bind call apply函数</h4><h5 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context,...extra</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">//这里不能用箭头函数，防止绑定函数为构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...arg</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.call(context,...extra.concat(arg))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="call"><a href="#call" class="headerlink" title="call"></a>call</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span>(<span class="params">context,...args</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>)&#123;</span><br><span class="line">        context = <span class="built_in">window</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    context = context <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? context : &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> key = <span class="built_in">Math</span>.random()</span><br><span class="line">    <span class="keyword">while</span> (context[key])&#123;</span><br><span class="line">        key = <span class="built_in">Math</span>.random()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    context[key] = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> result = context[key](...args)</span><br><span class="line">    <span class="keyword">delete</span> context[key]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">context,args = []</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(args)) <span class="keyword">throw</span> <span class="string">&#x27;参数必须为数组&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">context === <span class="literal">null</span> || context === <span class="literal">undefined</span></span>)</span>&#123;</span><br><span class="line">        context = <span class="built_in">window</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    context = context <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? context : &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> key = <span class="built_in">Math</span>.random()</span><br><span class="line">    <span class="keyword">while</span> (context[key])&#123;</span><br><span class="line">        key = <span class="built_in">Math</span>.random()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    context[key] = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> result = context[key](...args)</span><br><span class="line">    <span class="keyword">delete</span> context[key]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="请简述JavaScript中的this"><a href="#请简述JavaScript中的this" class="headerlink" title="请简述JavaScript中的this"></a>请简述<code>JavaScript</code>中的<code>this</code></h3><hr>
<p>this取值符合以下规则：</p>
<p>1.在调用函数时使用<code>new</code>关键字，函数内的<code>this</code>是一个全新的对象。</p>
<p>2.如果<code>apply</code>、<code>call</code>或<code>bind</code>方法用于调用、创建一个函数，函数内的<code>this</code>就是作为参数传入这些方法的对象。</p>
<p>3.当函数作为对象里的方法被调用时，函数内的this是调用该函数的对象。比如当<code>obj.method()</code>被调用时，函数内的<code>this</code>将绑定到<code>obj</code>对象。</p>
<p>4.如果调用函数不符合上述规则，那么<code>this</code>的值将指向全局对象（global object）。浏览器环境下<code>this</code>的值指向<code>window</code>对象，但是在严格模式下(<code>&#39;use strict&#39;</code>)，<code>this</code>的值为<code>undefined</code>。</p>
<p>5.如果符合上述多个规则，则较高的规则（1号最高，4号最低）将决定<code>this</code>的值。</p>
<p>6.如果该函数是ES2015中的箭头函数，将忽略上面的所有规则，<code>this</code>被设置为它被创建时的上下文。</p>
<h3 id="和-的区别是什么"><a href="#和-的区别是什么" class="headerlink" title="==和===的区别是什么"></a><code>==</code>和<code>===</code>的区别是什么</h3><hr>
<p><code>==</code>是抽象相等运算符，而<code>===</code>是严格相等运算符。<code>==</code>运算符是在进行必要的类型转换后，再比较。<code>===</code>运算符不会进行类型转换，所以如果两个值不是相同的类型，会直接返回<code>false</code>。使用<code>==</code>时，可能发生一些特别的事情，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="string">&#x27;1&#x27;</span>; <span class="comment">//true</span></span><br><span class="line"><span class="number">1</span> == [<span class="number">1</span>]; <span class="comment">//true</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span>; <span class="comment">//true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;&#x27;</span>; <span class="comment">//true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;0&#x27;</span> <span class="comment">//true</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>如果对<code>==</code>和<code>===</code>的概念不是特别了解，建议大多数情况下使用<code>===</code>。</p>
<h3 id="箭头函数和普通函数有什么区别"><a href="#箭头函数和普通函数有什么区别" class="headerlink" title="箭头函数和普通函数有什么区别"></a>箭头函数和普通函数有什么区别</h3><hr>
<ul>
<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象，用<code>call</code>、<code>apply</code>、<code>bind</code>也不能改变<code>this</code>的指向。</li>
<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用<code>rest</code>参数替代。</li>
<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作<code>Generator</code>函数。</li>
<li>箭头函数没有原型对象<code>prototype</code>。</li>
</ul>
<h3 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a><code>null</code>和<code>undefined</code>的区别</h3><hr>
<p><code>null</code>表示一个对象是“没有值”的对象，也就是值为“空”</p>
<p><code>undefined</code>表示一个变量声明了没有初始化（赋值）</p>
<p><code>undefined</code>和<code>null</code>在if语句中，都会被自动转化为<code>false</code></p>
<p><code>undefined</code>不是一个有效的JSON，而<code>null</code>是</p>
<p><code>undefined</code>的类型（typeof）是<code>undefined</code></p>
<p><code>null</code>的类型是（typeof）是<code>object</code></p>
<p>JavaScript将未赋值的变量默认值设为<code>undefined</code></p>
<p>JavaScript从来不会将变量设为<code>null</code>。它是用来让程序员表明某个用var声明的变量是没有值的</p>
<h3 id="prototype和-proto-的关系是什么"><a href="#prototype和-proto-的关系是什么" class="headerlink" title="prototype和__proto__的关系是什么"></a><code>prototype</code>和<code>__proto__</code>的关系是什么</h3><hr>
<p>先说结论：</p>
<p>1.<code>prototype</code>用于访问函数的原型对象。</p>
<p>2.<code>__proto__</code>用于访问对象实例的原型对象（或者使用<code>Object.getPrototypeOf()</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> test = <span class="keyword">new</span> Test()</span><br><span class="line">    test.__proto__ == Test.prototype <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，函数拥有<code>prototype</code>属性，对象实例拥有<code>__proto__</code>属性，它们都是用来访问原型对象的。</p>
<p>函数有点特别，它不仅是个函数，也是个对象。所以它也有<code>__proto__</code>属性。</p>
<p>__为什么会这样呢?__因为函数是内置构造函数<code>Function</code>的实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;function Test()&#123;&#125;&#x27;</span>)</span><br><span class="line">test.__proto__ == <span class="built_in">Function</span>.prototype <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>这样看起来好像有点复杂，我们可以换个角度来看。<code>Object</code>其实也是内置构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>() <span class="comment">// 我们可以把这个 obj 想象成原型对象 prototype</span></span><br><span class="line">obj.__proto__ == <span class="built_in">Object</span>.prototype <span class="comment">// true  换个角度来看，相当于 prototype.__proto__ == Object.prototype</span></span><br></pre></td></tr></table></figure>

<p>从这一点来看，是不是更好理解一点。</p>
<p>为了防止无休止的循环下去，所以<code>Object.prototype.__proto__</code>是指向<code>null</code>的，<code>null</code>是万物的重点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__ == <span class="literal">null</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>既然null是万物的终点，那使用<code>Object.create(null)</code>创建对象时没有<code>__proto__</code>属性的，也没有<code>prototype</code>属性。</p>
<h3 id="Object与Map的区别"><a href="#Object与Map的区别" class="headerlink" title="Object与Map的区别"></a>Object与Map的区别</h3><hr>
<p>1.Object只能选择字符、数值、符号作为 key，Map 则可以使用任何类型的数据作为 key。</p>
<p>2.Map实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。Chrome Opera 中使用 for-in 语句遍历 Object 属性时会遵循一个规律：它们会先提取所有 key 的 parseFloat 值为非负整数的属性，然后根据数字顺序对属性排序首先遍历出来，然后按照对象定义的顺序遍历余下的所有属性。其它浏览器则完全按照对象定义的顺序遍历属性。</p>
<h4 id="选择Object还是Map"><a href="#选择Object还是Map" class="headerlink" title="选择Object还是Map"></a>选择Object还是Map</h4><p>对于多数Web开发任务来说，选择 Object 还是 Map 只是个人偏好问题，影响不大。不过，对于在乎内存和性能的开发者来说，对象和映射之间确实存在显著的差别。</p>
<h5 id="1-内存占用"><a href="#1-内存占用" class="headerlink" title="1.内存占用"></a>1.内存占用</h5><p>Object 和 Map 的工程级实现在不同浏览器间存在明显差异，但存储单个键/值对所占用的内存数量都会随键的数量线性增加。批量添加或删除键/值对则取决于各浏览器对该类型内存分配的工程实现。</p>
<p>不同浏览器的情况不同，但给定固定大小的内存， Map 大约可以比 Object 多存储50%的键/值对。</p>
<h5 id="2-插入性能"><a href="#2-插入性能" class="headerlink" title="2.插入性能"></a>2.插入性能</h5><p>向 Object 和 Map 中插入新键/值对的消耗大致相当，不过插入Map 在所有浏览器中一般会稍微快一点儿。对这两个类型来说，插入速度并不会随着键/值对数量而线性增加。</p>
<p>如果代码涉及大量插入操作，那么显然 Map 的性能更佳。</p>
<h5 id="3-查找速度"><a href="#3-查找速度" class="headerlink" title="3.查找速度"></a>3.查找速度</h5><p>与插入不同，从大型 Object 和 Map 中查找键/值对的性能差异极小，但如果只包含少量键/值对，则 Object 有时候速度更快。在把 Object 当成数组使用的情况下（比如使用连续整数作为属性），浏览器引擎可以进行优化，在内存中使用更高效的布局。</p>
<p>这对 Map 来说是不可能的。对这两个类型而言，查找速度不会随着键/值对数量增加而线性增加。如果代码涉及大量查找操作，那么某些情况下可能选择 Object 更好一些。</p>
<h5 id="4-删除性能"><a href="#4-删除性能" class="headerlink" title="4.删除性能"></a>4.删除性能</h5><p>使用 delete 删除 Object 属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此，出现了一些伪删除对象属性的操作，包括把属性值设置为 undefined 或 null 。但很多时候，这都是一 种讨厌的或不适宜的折中。</p>
<p>而对大多数浏览器引擎来说， Map 的 delete() 操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择 Map 。</p>
<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><hr>
<p>Ajax(asynchronous JavaScript and XML) 是客户端上创建异步 Web 应用的一种 Web 开发技术。</p>
<p>借助 Ajax，Web 应用可以异步（在后台）向服务器发送数据和从服务器检索数据，而不会干扰现有页面的显示和行为。通过将数据交换层与表示层分离，Ajax 允许网页和扩展 Web 应用程序动态更改内容，而无需重新加载整个页面。</p>
<p>XMLHttpRequest API 经常用于异步通信。此外还有最近流行的fetch API。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.onload = <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">xhr.status == <span class="number">200</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xhr.response)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;https://api.github.com/&#x27;</span>)</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>

<h3 id="使用Ajax的优缺点分别是什么"><a href="#使用Ajax的优缺点分别是什么" class="headerlink" title="使用Ajax的优缺点分别是什么"></a>使用Ajax的优缺点分别是什么</h3><hr>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>交互性更好。来自服务器的新内容可以动态更改，无需重新加载整个页面。</li>
<li>减少与服务器的连接，因为脚本和样式只需要被请求一次。</li>
<li>状态可以维护在一个页面上。JavaScript 变量和 DOM 状态将得到保持，因为主容器页面未被重新加载。</li>
<li>基本上包括大部分 SPA 的优点。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>动态网页很难收藏。</li>
<li>如果 JavaScript 已在浏览器中被禁用，则不起作用。</li>
<li>有些网络爬虫不执行 JavaScript，也不会看到 JavaScript 加载的内容。</li>
<li>基本上包括大部分 SPA 的缺点。</li>
</ul>
<h3 id="Ajax和Fetch区别"><a href="#Ajax和Fetch区别" class="headerlink" title="Ajax和Fetch区别"></a>Ajax和Fetch区别</h3><hr>
<ul>
<li>ajax是使用XMLHttpRequest对象发起的，但是用起来很麻烦，所以ES6新规范就有了fetch，fetch发一个请求不用像ajax那样写一大堆代码。</li>
<li>使用fetch无法取消一个请求，这是因为fetch基于Promise，而Promise无法做到这一点。</li>
<li>在默认情况下，fetch不会接受或者发送cookies。</li>
<li>fetch没有办法原生监测请求的进度，而XMLHttpRequest可以。</li>
<li>fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理。</li>
<li>fetch由于是ES6规范，兼容性上比不上XMLHttpRequest。</li>
</ul>
<h3 id="实现async-await"><a href="#实现async-await" class="headerlink" title="实现async/await"></a>实现async/await</h3><hr>
<p>利用 <code>generator()</code> 实现 <code>async/await</code> 主要就是用一个函数（自动执行器）来包装 <code>generator()</code>，从而实现自动执行 <code>generator()</code>。</p>
<p>每次执行 <code>next()</code> 返回的 <code>&#123; value, done &#125;</code> 中的 value 是一个 Promise，所以要等它执行完毕后再执行下一次 <code>next()</code>。</p>
<p>即在它的后面加一个 <code>then()</code> 函数，并且在 <code>then()</code> 函数中执行 <code>next()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> r(data), <span class="number">100</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> data1 = <span class="keyword">yield</span> t(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(data1)</span><br><span class="line">    <span class="keyword">const</span> data2 = <span class="keyword">yield</span> t(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(data2)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">generator</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> gen = generator()</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextFun</span>) </span>&#123;</span><br><span class="line">	    <span class="comment">// 每一次 next() 都是返回这样的数据 &#123; value: xx, done: false &#125;，结束时 done 为 true</span></span><br><span class="line">	    <span class="keyword">let</span> next</span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 如果 generator() 执行报错，需要 reject 给外面的 catch 函数</span></span><br><span class="line">		next = nextFun()</span><br><span class="line">	    &#125; <span class="function"><span class="title">catch</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> reject(e)</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// done: true 代表 generator() 结束了</span></span><br><span class="line">	    <span class="keyword">if</span> (next.done) &#123;</span><br><span class="line">		<span class="keyword">return</span> resolve(next.value)</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="built_in">Promise</span>.resolve(next.value).then(</span><br><span class="line">		(val) =&gt; step(<span class="function">() =&gt;</span> gen.next(val)), <span class="comment">// 通过 next(val) 将 val 传给 yield 后面的变量 </span></span><br><span class="line">		(err) =&gt; step(<span class="function">() =&gt;</span> gen.trhow(err)),</span><br><span class="line">	    )</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	step(<span class="function">() =&gt;</span> gen.next())</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="keyword">async</span>(test).then(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(val))</span><br></pre></td></tr></table></figure>

<h3 id="格式化金钱，每千分位加逗号"><a href="#格式化金钱，每千分位加逗号" class="headerlink" title="格式化金钱，每千分位加逗号"></a>格式化金钱，每千分位加逗号</h3><hr>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = str.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        s = str[i] + s</span><br><span class="line">        count++</span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="string">&#x27;,&#x27;</span> + s</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/(\d)(?=(?:\d&#123;3&#125;)+$)/g</span>, <span class="string">&#x27;$1,&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for…in和for…of的区别"><a href="#for…in和for…of的区别" class="headerlink" title="for…in和for…of的区别"></a>for…in和for…of的区别</h3><hr>
<p>for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下</p>
<ul>
<li>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li>
<li>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li>
<li>对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</li>
</ul>
<p><strong>总结：</strong> for…in 循环主要是为了遍历对象而生，不适用于遍历数组；for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</p>
<h3 id="数据类型检测方案"><a href="#数据类型检测方案" class="headerlink" title="数据类型检测方案"></a>数据类型检测方案</h3><hr>
<h4 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a>1.typeof</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;mc&#x27;</span>);            <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Symbol</span>)           <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">console</span>.log());   <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>优点：能够快速区分基本数据类型</p>
<p>缺点：不能将Object、Array和Null区分，都返回object</p>
<h4 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof"></a>2.instanceof</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false  </span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象</p>
<p>缺点：Number，Boolean，String基本数据类型不能判断</p>
<h4 id="3-Object-prototype-toString-call"><a href="#3-Object-prototype-toString-call" class="headerlink" title="3.Object.prototype.toString.call()"></a>3.Object.prototype.toString.call()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="number">1</span>));                      <span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">true</span>));                   <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="string">&#x27;mc&#x27;</span>));                   <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call([]));                     <span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(&#123;&#125;));                     <span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;));           <span class="comment">//[object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">undefined</span>));              <span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">null</span>));                   <span class="comment">//[object Null]</span></span><br></pre></td></tr></table></figure>

<p>优点：精准判断数据类型</p>
<p>缺点：写法繁琐不容易记，推荐进行封装后使用</p>
<h3 id="浏览器的垃圾回收机制"><a href="#浏览器的垃圾回收机制" class="headerlink" title="浏览器的垃圾回收机制"></a>浏览器的垃圾回收机制</h3><hr>
<h4 id="1-垃圾回收的概念"><a href="#1-垃圾回收的概念" class="headerlink" title="1.垃圾回收的概念"></a>1.垃圾回收的概念</h4><p><strong>垃圾回收：</strong>JavaScript代码运行时，需要分配内存空间来存储变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。</p>
<p><strong>回收机制：</strong></p>
<ul>
<li>Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。</li>
<li>JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。</li>
<li>不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。</li>
</ul>
<h4 id="2-垃圾回收的方式"><a href="#2-垃圾回收的方式" class="headerlink" title="2.垃圾回收的方式"></a>2.垃圾回收的方式</h4><p>浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。</p>
<p><strong>1)标记清除</strong></p>
<ul>
<li>标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。</li>
<li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</li>
</ul>
<p><strong>2)引用计数</strong></p>
<ul>
<li><p>另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。</p>
</li>
<li><p>这种方法会引起<strong>循环引用</strong>的问题：例如：<code> obj1</code>和<code>obj2</code>通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，<code>obj1</code>和<code>obj2</code>还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line">    obj1.a = obj2; <span class="comment">// obj1 引用 obj2</span></span><br><span class="line">    obj2.a = obj1; <span class="comment">// obj2 引用 obj1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，就要手动释放变量占用的内存：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj1.a =  <span class="literal">null</span></span><br><span class="line">obj2.a =  <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h4 id="3-减少垃圾回收"><a href="#3-减少垃圾回收" class="headerlink" title="3.减少垃圾回收"></a>3.减少垃圾回收</h4><p>虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。</p>
<ul>
<li><strong>对数组进行优化：</strong> 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。</li>
<li><strong>对</strong><code>object</code><strong>进行优化：</strong> 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。</li>
<li><strong>对函数进行优化：</strong> 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</li>
</ul>
</li>
</ul>
<h3 id="哪些情况会导致内存泄漏"><a href="#哪些情况会导致内存泄漏" class="headerlink" title="哪些情况会导致内存泄漏"></a>哪些情况会导致内存泄漏</h3><hr>
<ul>
<li><strong>意外的全局变量：</strong> 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li>
<li><strong>被遗忘的计时器或回调函数：</strong> 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>
<li><strong>脱离 DOM 的引用：</strong> 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li>
<li><strong>闭包：</strong> 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/01/20/CSS_%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            CSS_前端知识点与面试题
          
        </div>
      </a>
    
    
      <a href="/2022/01/17/jsp/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">基于JavaWeb的图书商城管理系统</div>
      </a>
    
  </nav>

   
 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2019-2022
        <i class="ri-heart-fill heart_icon"></i> 二百八
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
        <li>
          <a href="https://beian.miit.gov.cn/" target="_black" rel="nofollow">粤ICP备88888888</a>
        </li>
        
    </ul>
    <ul>
      
      <li>
          <img src="/images/beian.png"></img>
          <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=01234567890123" target="_black" rel="nofollow">粤公网安备01234567890123号</a>
      </li>
        
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="just chill"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯奶茶吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>


<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=592701&auto=0&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>